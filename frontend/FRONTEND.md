# Документация фронтенда

## Обзор

Фронтенд приложения для управления списком из 1 000 000 элементов реализован на Vue 3 с TypeScript. Приложение состоит из двух основных окон: левое окно отображает все элементы (кроме выбранных), правое окно - выбранные элементы с возможностью сортировки через Drag&Drop.

## Архитектура

### Структура проекта

```
frontend/src/
├── components/
│   ├── ItemsList.vue          # Левое окно - все элементы
│   ├── SelectedList.vue       # Правое окно - выбранные элементы
│   └── AddItemForm.vue        # Форма добавления нового элемента
├── composables/
│   ├── useInfiniteScroll.ts   # Композабл для инфинити-скролла
│   └── useStateSync.ts        # Композабл для синхронизации состояния
├── services/
│   └── api.ts                 # API сервис для работы с бэкендом
├── App.vue                    # Главный компонент
├── main.ts                    # Точка входа
└── style.css                  # Глобальные стили
```

### Компоненты

#### App.vue
Главный компонент приложения, который:
- Инициализирует состояние при загрузке
- Управляет синхронизацией состояния с сервером
- Координирует взаимодействие между левым и правым окнами
- Обрабатывает события добавления/удаления элементов

#### ItemsList.vue (Левое окно)
Компонент для отображения всех элементов, кроме выбранных:
- **Фильтрация по ID**: Поле ввода с дебаунсингом (500ms) для фильтрации элементов
- **Инфинити-скролл**: Автоматическая подгрузка элементов порциями по 20 при прокрутке
- **Добавление в выбранные**: Кнопка для каждого элемента для добавления в правый список
- **Добавление новых элементов**: Интегрированная форма для создания элементов с произвольным ID

#### SelectedList.vue (Правое окно)
Компонент для управления выбранными элементами:
- **Фильтрация по ID**: Аналогично левому окну, с сохранением порядка сортировки
- **Drag&Drop сортировка**: Использование библиотеки `vue-draggable-next` для изменения порядка элементов
- **Инфинити-скролл**: Подгрузка выбранных элементов порциями по 20
- **Удаление из выбранных**: Кнопка для каждого элемента

#### AddItemForm.vue
Форма для добавления новых элементов:
- Поле для ввода ID (обязательное)
- Поле для ввода label (опциональное, генерируется автоматически если не указано)
- Валидация и обработка ошибок
- Уведомления об успешном добавлении

### Композаблы (Composables)

#### useInfiniteScroll.ts
Реализует логику инфинити-скролла с использованием Intersection Observer API:
- Отслеживает появление элемента-маркера в области видимости
- Автоматически вызывает функцию загрузки при достижении конца списка
- Учитывает состояние загрузки и наличие дополнительных элементов
- Настраиваемый отступ (rootMargin) для предзагрузки

#### useStateSync.ts
Управляет синхронизацией состояния с сервером:
- Загружает состояние при инициализации приложения
- Сохраняет состояние в localStorage как fallback
- Восстанавливает состояние из localStorage при ошибке сервера
- Автоматически синхронизирует изменения с сервером

### Сервисы

#### api.ts
Централизованный API сервис для всех запросов к бэкенду:
- `getItems()` - получение всех элементов с пагинацией и фильтрацией
- `getSelected()` - получение выбранных элементов с пагинацией и фильтрацией
- `addItem()` - добавление нового элемента
- `addToSelected()` - добавление элемента в выбранные
- `removeFromSelected()` - удаление элемента из выбранных
- `reorderSelected()` - изменение порядка элементов (Drag&Drop)
- `getState()` - получение текущего состояния
- `setState()` - сохранение состояния

Все методы используют нативный `fetch` API и обрабатывают ошибки единообразно.

## Ключевые особенности реализации

### Инфинити-скролл

Инфинити-скролл реализован с помощью Intersection Observer API:
1. В конце списка размещается невидимый элемент-маркер (`observerTarget`)
2. При появлении маркера в области видимости автоматически загружается следующая страница
3. Используется отступ 100px для предзагрузки данных
4. Учитывается состояние загрузки, чтобы избежать дублирующих запросов

### Drag&Drop сортировка

Сортировка реализована с использованием библиотеки `vue-draggable-next`:
1. Элементы можно перетаскивать за специальную ручку (⋮⋮)
2. При изменении порядка отправляется запрос на сервер
3. Порядок сохраняется даже при применении фильтра
4. Визуальная обратная связь при перетаскивании (прозрачность, тень)

### Фильтрация

Фильтрация работает с дебаунсингом (500ms):
- Запросы отправляются только после прекращения ввода
- При фильтрации сохраняется порядок сортировки в правом окне
- Фильтрация работает независимо для каждого окна
- При очистке фильтра восстанавливается полный список

### Сохранение состояния

Состояние сохраняется в двух местах:
1. **Сервер**: Основное хранилище, синхронизируется при каждом изменении
2. **localStorage**: Fallback для восстановления при ошибках сервера

При загрузке приложения:
1. Пытается загрузить состояние с сервера
2. При ошибке загружает из localStorage и восстанавливает на сервере
3. Сохраняет выбранные элементы и их порядок

### Обработка батчинга

Бэкенд использует батчинг для оптимизации запросов:
- **Добавление элементов**: батчинг 10 секунд
- **Чтение/изменение**: батчинг 1 секунда

Фронтенд учитывает это:
- Показывает индикаторы загрузки при ожидании ответа
- Использует оптимистичные обновления UI где возможно
- Обрабатывает задержки ответов корректно

## Переменные окружения

Создайте файл `.env` в корне проекта `frontend/`:

```env
VITE_API_URL=http://localhost:3000/api
```

Vite автоматически загружает переменные с префиксом `VITE_`.

## Запуск приложения

1. Установите зависимости:
```bash
yarn install
```

2. Убедитесь, что бэкенд запущен на `http://localhost:3000`

3. Запустите dev-сервер:
```bash
yarn dev
```

4. Откройте браузер по адресу, указанному в консоли (обычно `http://localhost:5173`)

## Производительность

### Оптимизации

1. **Ленивая загрузка**: Загружается только 20 элементов за раз
2. **Дебаунсинг фильтрации**: Снижает количество запросов при вводе
3. **Мемоизация**: Вычисляемые свойства кэшируются Vue
4. **Intersection Observer**: Эффективное отслеживание прокрутки без постоянных проверок

### Ограничения

- Виртуализация списков не используется, так как на экране максимум 20 элементов
- Все запросы проходят через очередь на бэкенде с батчингом
- Состояние хранится в памяти на сервере (без БД)

## Обработка ошибок

- Все API запросы обрабатывают ошибки и показывают сообщения пользователю
- При ошибке загрузки состояния используется fallback из localStorage
- Ошибки логируются в консоль для отладки
- Пользователь видит понятные сообщения об ошибках

## Адаптивность

Приложение адаптивно:
- На больших экранах: два окна рядом (flex layout)
- На мобильных устройствах (< 768px): окна располагаются вертикально

## Технологии

- **Vue 3** - фреймворк с Composition API
- **TypeScript** - типизация
- **vue-draggable-next** - Drag&Drop функциональность
- **Intersection Observer API** - инфинити-скролл
- **Vite** - сборщик и dev-сервер

## Взаимодействие с бэкендом

Все запросы идут на эндпоинты:
- `GET /api/items` - получение всех элементов
- `GET /api/selected` - получение выбранных элементов
- `POST /api/items` - добавление нового элемента
- `POST /api/selected` - добавление в выбранные
- `PUT /api/selected/order` - изменение порядка
- `DELETE /api/selected/:id` - удаление из выбранных
- `GET /api/state` - получение состояния
- `POST /api/state` - сохранение состояния

Все запросы проходят через очередь с дедупликацией и батчингом на бэкенде.

